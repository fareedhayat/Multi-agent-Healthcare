i've this multi-agent project that i've created using autogen 0.5.6 
https://microsoft.github.io/autogen/stable/index.html

my agents are
doctor.py:
async def review_patient_case() -> Dict:
    medical_history = await collect_medical_history()
    current_symptoms = await get_current_situation()
    if not current_symptoms:
        return {"error": "Incomplete patient data"}
    
    try:
        print('review patient case')
        patient_name = medical_history[0]['Patient info']['patient_name']
        recommendations = await generate_clinical_recommendations(
            medical_history=medical_history,
            symptoms=current_symptoms
        )

        diagnosis = await confirm_diagnosis(recommendations["possible_diagnoses"])
        treatment_plan = await create_treatment_plan(recommendations["treatment_options"])
        diagnostic_test = recommendations["diagnostic_tests"]
        follow_up = await schedule_follow_up(diagnosis)

        # monitoring here and sends a notication after formatting the return statement

        results = {
            "diagnosis": diagnosis,
            "treatment_plan": treatment_plan,
            "diagnostic_test": diagnostic_test,
            "follow_up": follow_up
        }

        monitoring_status = await monitor_patient_case(
            patient_name=patient_name,
            clinical_data=results
        )

        print(monitoring_status)

        print(results)
        return json.dumps({
            "diagnosis": "Common Cold",
            "treatment_plan": ["PRIMARY: antibiotics"],
            "diagnostic_test": ["throat_swab", "none"]
        })
        
    except Exception as e:
        return {"error": f"Case review failed: {str(e)}"}

async def confirm_diagnosis(possible_diagnoses: List[str]) -> str:
    """Doctor selects most likely diagnosis"""
    # In this case returning the first one
    return possible_diagnoses[0] if possible_diagnoses else "Unknown"

async def create_treatment_plan(treatment_options: List[str]) -> List[str]:
    """Doctor finalizes treatment plan"""
    # Returns the first two
    return [
        f"PRIMARY: {treatment_options[0]}",
        # f"SECONDARY: {treatment_options[1]}" if len(treatment_options) > 1 else ""
    ]

async def schedule_follow_up(diagnosis: str) -> str:
    """Determine follow-up timing based on condition"""
    follow_up_days = {
        "acute": 7,
        "chronic": 30,
        "preventive": 90
    }.get(diagnosis.lower(), 14)
    
    follow_up_date = (datetime.now() + timedelta(days=follow_up_days)).strftime("%Y-%m-%d")
    return f"Follow-up in {follow_up_days} days ({follow_up_date})"

doctor_agent = AssistantAgent(
    name="DoctorAgent",
    model_client=model_client,
    system_message="You are DoctorAgent. Review patient history and symptoms, suggest a primary diagnosis, create a treatment plan, and schedule follow‑ups. Report errors clearly and use an empathetic, concise tone.",
    tools=[review_patient_case],
    # reflect_on_tool_use=True
)

appointment.py:
async def schedule_appointment() -> str:
    # patient_name = await user.aask("What is the patient's name?")
    patient_name = input_once("Please enter your name: ").strip()
    raw_date = input_once("Enter appointment date (e.g. 2025-05-05 or May 5, 2025): ").strip()
    # if not patient_name:
    #     patient_name = await user.aask("Please enter the patient's name:")

    # # Ask for date if not provided
    # if not raw_date:
    #     raw_date = await user.aask("Enter the appointment date (e.g. 2025-05-05 or May 5, 2025):")

    date = normalize_date(raw_date)
    print(date)
    
    busy = await get_events(date)
    print(busy)
    free_slots = get_free_slots(date, busy)
    if not free_slots:
        print(f"Dr. is fully booked on {date}. Please restart and choose another date.")
        return

    print(f"\nAvailable slots on {date}:")
    for idx, slot in enumerate(free_slots, 1):
        print(f"  {idx}. {slot}")
    choice = input("\nSelect a slot by number: ").strip()
    if not choice.isdigit() or not (1 <= int(choice) <= len(free_slots)):
        print("Invalid selection. Please restart and pick a valid number.")
        return
    time = free_slots[int(choice) - 1]
    
    start_iso = f"{date}T{time}:00"
    end_iso = (datetime.fromisoformat(start_iso) + timedelta(minutes=30)) \
        .strftime("%Y-%m-%dT%H:%M:%S")

    try:
        event = await create_outlook_event(
            patient_name=patient_name,
            start_datetime=start_iso,
            end_datetime=end_iso,
        )

        original_details = await get_event_details(event.id)

    except Exception as e:
        print(f"Failed to schedule appointment: {e}")

    await monitor_appointments(event.id, "created", original_details=original_details)

    return (
        f"##### Appointment Scheduled \n"
        f"**Patient:** {patient_name}\n"
        f"**Date:** {date}\n"
        f"**Time:** {time}\n"
        f"**Appointment ID:** {event.id}\n\n"
        f"Your appointment has been added to the calendar.\n\n"
        f"AGENT SUMMARY: Created Outlook event and returned its ID for tracking."
    )

async def reschedule_appointment() -> str:
    '''
    Get the appointment ID
    Use appointment id to get details from Graph API
    Same functionality as the schedule appointment
    '''
    appointment_id = input('Please enter the appointment ID: ')
    new_date = input('Please enter the new date: ')
    original_details = await get_event_details(appointment_id)
    patient_name = original_details['patient_name']

    if not patient_name:
        return f"Could not find details for appointment {appointment_id}."
    
    response = await delete_outlook_event(appointment_id)
    if not response:
        return (f"Failed to reschedule appointment")
    
    # new_date = input("Enter new date (e.g. 2025-05-05 or May 5, 2025): ").strip()
    date = normalize_date(new_date)
    
    busy = await get_events(date)
    free_slots = get_free_slots(date, busy)
    if not free_slots:
        print(f"Dr. is fully booked on {date}. Please restart and choose another date.")
        return

    print(f"\nAvailable slots on {date}:")
    for idx, slot in enumerate(free_slots, 1):
        print(f"  {idx}. {slot}")
    choice = input("\nSelect a slot by number: ").strip()
    if not choice.isdigit() or not (1 <= int(choice) <= len(free_slots)):
        print("Invalid selection. Please restart and pick a valid number.")
        return
    time = free_slots[int(choice) - 1]
    
    start_iso = f"{date}T{time}:00"
    end_iso = (datetime.fromisoformat(start_iso) + timedelta(minutes=30)) \
        .strftime("%Y-%m-%dT%H:%M:%S")

    try:
        event = await create_outlook_event(
            patient_name=patient_name,
            start_datetime=start_iso,
            end_datetime=end_iso,
        ) 

    except Exception as e:
        return(f"Failed to schedule appointment: {e}")
    
    await monitor_appointments(event.id, "rescheduled", original_details=original_details)
    return (
        f"##### Appointment Rescheduled\n"
        f"**Appointment ID:** {event.id}\n"
        f"**New Date:** {new_date}\n"
        f"**New Time:** {start_iso}\n\n"
        f"Your appointment has been successfully rescheduled."
    )

async def delete_appointment(appointment_id: str) -> str:
    appointment_id = input_once('Enter the appointment ID to delete the appointment:' )
    current_details = await get_event_details(appointment_id)
    response = await delete_outlook_event(appointment_id)
    if not response:
        return (f"Failed to delete appointment")

    await monitor_appointments(appointment_id, "deleted", current_details=current_details)
    return (
        f"##### Appointment Deleted\n"
        f"**Appointment ID:** {appointment_id}\n"
        f"Your appointment has been successfully deleted."
    )

appointment_agent = AssistantAgent(
    name="AppointmentAgent",
    model_client=model_client,
    system_message="You are AppointmentAgent. Help users schedule, reschedule, or delete 30‑minute patient appointments via Outlook. Prompt for name and date, show available slots, call Graph API, and confirm success or errors in brief Markdown.",
    tools=[schedule_appointment, reschedule_appointment, delete_appointment]
)

clinical_recommendation.py:
async def generate_medical_kb(medical_history: Dict, symptoms: List[str]) -> Dict:
    prompt = f"""
    You are a medical assistant. Based on the following medical history and symptoms, generate a medical knowledge base as valid JSON.

    Medical History: {medical_history}
    Symptoms: {symptoms}

    Respond ONLY with a JSON object in the following format (no explanation):

    {{
    "Disease A": {{
        "diagnostic_criteria": ["symptom1", "symptom2"],
        "treatments": ["treatment1", "treatment2"],
        "tests": ["test1", "test2"],
        "urgency": "low"
    }},
    "Disease B": {{
        "diagnostic_criteria": ["symptom3"],
        "treatments": ["treatment3"],
        "tests": ["test3"],
        "urgency": "moderate"
    }}
    }}

    Limit to 2 diseases only. Use short keywords (not full sentences) for criteria, treatments, and tests.
    """
    response = await model_client.create([SystemMessage(content=prompt)])
    content = response.content.strip()
    print("Raw content from model:\n", content)
    cleaned_content = re.sub(r"^```json|```$", "", content.strip(), flags=re.MULTILINE).strip()


    try:
        kb = json.loads(cleaned_content)
    except json.JSONDecodeError as e:
        raise ValueError(f"Failed to parse model output. Cleaned content:\n{cleaned_content}\nError: {str(e)}")
    
    return kb

def normalize(text):
    return text.strip().lower().replace(" ", "_")


async def generate_clinical_recommendations(medical_history: Dict, symptoms: List[str]) -> Dict:
    try:
        possible_diagnoses = []
        diagnostic_tests = []
        MEDICAL_KB = await generate_medical_kb(medical_history, symptoms)
        for condition, data in MEDICAL_KB.items():
            symptom_matches = [
                s for s in symptoms if normalize(s) in [normalize(c) for c in data["diagnostic_criteria"]]
            ]
            if len(symptom_matches) >= 1:
                possible_diagnoses.append(condition)
                diagnostic_tests.extend(data.get("tests", []))


        treatment_options = []
        for diagnosis in possible_diagnoses:
            treatment_options.extend(MEDICAL_KB[diagnosis]["treatments"])
        
        result = {
            "possible_diagnoses": possible_diagnoses,
            "treatment_options": list(set(treatment_options)),
            "diagnostic_tests": list(set(diagnostic_tests)),
            "confidence_score": "60%" # get confidence score from the generation of medical knowledge base
        }
        print(result)
        return result
        
    except Exception as e:
        return {"error": f"Recommendation generation failed: {str(e)}"}


    

clinical_recommendation_agent = AssistantAgent(
    name="ClinicalRecommendationAgent",
    model_client=model_client,
    system_message="You are Clinical Recommendation Agent. Generate a two-disease JSON knowledge base (criteria, tests, treatments, urgency), match symptoms to diagnoses, list treatment options and tests, include a confidence score, and return only JSON.",
    tools=[generate_medical_kb, generate_clinical_recommendations]
)

insurance_verification.py:
INSURANCE_DATABASE = {
    "INS-123451": {
        "patient_name": "Haider Ali",
        "provider": "HealthCare Plus",
        "active": True,
        "coverage": {
            "general_consultation": {"copay": 20, "requires_authorization": False},
            "mri_scan": {"copay": 150, "requires_authorization": True}
        }
    },
    "INS-123452": {
        "patient_name": "Saim Ayub",
        "provider": "Wellness Shield",
        "active": True,
        "coverage": {
            "general_consultation": {"copay": 30, "requires_authorization": False}
        }
    }
}

PATIENT_INSURANCE_MAPPING = {
    "Haider Ali": "INS-123451",
    "Saim Ayub": "INS-123452"
}

async def get_insurance_id(patient_name: str) -> str:
    """Get insurance ID for a patient by name"""
    return PATIENT_INSURANCE_MAPPING.get(patient_name, "")

# print(asyncio.run(get_insurance_id('Haider Ali')))

async def verify_patient_coverage() -> Dict[str, Any]:
    """Full verification flow using patient name"""
    

    patient_name = input_once("Please enter your name: ")
    service = input_once('Enter the service you want to get: ')

    result = {
        "patient_name": patient_name,
        "insurance_found": False,
        "service_covered": False,
        "service": service,
        "coverage_details": {}
    }
    
    insurance_id = await get_insurance_id(patient_name)
    if not insurance_id:
        result["error"] = "No insurance found for patient"
        return result
    
    insurance_info = INSURANCE_DATABASE.get(insurance_id)
    if not insurance_info:
        result["error"] = "Insurance record not found"
        return result

    service_coverage = insurance_info["coverage"].get(service)
    is_covered = service_coverage is not None
        
    result.update({
        "insurance_found": True,
        "service_covered": is_covered,
        "insurance_id": insurance_id,
        "provider": insurance_info["provider"],
        "coverage_details": service_coverage if is_covered else {}
    })

    # monitoring here and sending a notification based on insurance available or not 
    await monitor_insurance_verification(result)

    return result 

# pprint(asyncio.run(verify_patient_coverage('Saim Ayub', 'general_consultation')))

insurance_verification_agent = AssistantAgent(
    name="InsuranceVerificationAgent",
    model_client=model_client,
    system_message="You are Insurance Verification Agent. Ask for patient name and service, verify coverage from the database, return a structured result with coverage details or clear error messages.",
    tools=[verify_patient_coverage, get_insurance_id],
)

patient_intake.py:
async def collect_basic_info() -> dict:
    name = input_once("Please enter your name: ").strip()
    age = input_once("Please enter your age: ").strip()
    address = input_once("Please enter your address: ").strip()

    return {"name": name, "age": age, "address": address}


async def collect_medical_history() -> List[Dict[str, str]]:
    input_paths = input_once("Enter paths to documents, separated by commas: ")
    documents = [doc.strip() for doc in input_paths.split(',') if doc.strip()]
    medical_history = []
    for idx, document in enumerate(documents, 1):
        patient_info, medical_info = await analyze_previous_records(document)
        medical_history.append({f'Document':f'Document {idx}', 'Patient info': patient_info, 'Medical Info': medical_info})
    
    return medical_history

_cached_situation: list[str] | None = None

async def get_current_situation() -> list[str]:
    global _cached_situation
    if _cached_situation is not None:
        return _cached_situation

    current_situation: list[str] = []
    first = input_once("What are you feeling right now? ")
    current_situation.append(first)

    while True:
        more = input("Any other symptoms? (type 'no' to stop) ")
        if more.strip().lower() == "no":
            break
        current_situation.append(more)

    _cached_situation = current_situation
    return current_situation

patient_intake_agent = AssistantAgent(
    name="PatientIntakeAgent",
    model_client=model_client,
    system_message="You are Patient IntakeAgent. Collect basic patient info (name, age, address) and prior records paths, then gather current symptoms until the user stops. Cache symptoms to avoid repeats.",
    tools=[collect_basic_info, get_current_situation, collect_medical_history]
)

monitoring.py:
async def monitor_appointments(
    appointment_id: str, 
    action: str,
    **kwargs: Any
) -> str:
    try:
        # current_details = await get_event_details(appointment_id)
        # if not current_details:
        #     return "Error: Could not retrieve appointment details"

        messages = []
        
        if action == "created":
            current_details = kwargs.get("original_details")
            messages.append(await handle_new_appointment(current_details))
            
        elif action == "rescheduled":
            current_details = await get_event_details(appointment_id)
            original_details = kwargs.get("original_details")
            if original_details:
                messages.append(await handle_reschedule(current_details, original_details))
            
        elif action == "deleted":
            current_details = kwargs.get("current_details")
            if current_details:
                messages.append(await handle_deletion(current_details))

        if messages:
            print(current_details)
            await notify_appointment(current_details, messages)
        # print(notification["message"])
        print(messages)
        print(f"Monitoring completed for {appointment_id}")
    
    except Exception as e:
        print(f"Monitoring error: {str(e)}")
        return "Monitoring failed"

async def monitor_patient_case(patient_name: str, clinical_data: dict,):
    print('monitor patient case function')
    message = format_clinical_summary(clinical_data)
    notification_status = await notify_clinical_review(
        patient_name=patient_name,
        message_params=message,
    )

    return notification_status

async def monitor_insurance_verification(insurance_data: dict):
    try:
        patient_name = insurance_data['patient_name']
        notification_type = "INSURANCE_VERIFIED" if insurance_data.get("insurance_found") else "INSURANCE_NOT_FOUND"
        
        if insurance_data.get("insurance_found"):
            response = await notify_insurance_status(
                patient_name=patient_name,
                insurance_data=insurance_data,
                message_type=notification_type
            )
        else:
            response = await notify_insurance_status(
                patient_name=patient_name,
                insurance_data=insurance_data,
                message_type=notification_type
            )

        print(f"Notification Status: {response.get('status', 'unknown')}")
        if response.get("status") == "failure":
            print(f"Email Error: {response.get('message')}")

    except Exception as e:
        print(f"Insurance monitoring failed: {str(e)}")
        # await notify_insurance_status(
        #     insurance_data={"error": str(e)},
        #     message_type="INSURANCE_ERROR"
        # )

def format_clinical_summary(clinical_data: dict) -> dict:
    return {
        "diagnosis": clinical_data.get("diagnosis", "Pending diagnosis"),
        "treatment_plan": "\n- ".join(clinical_data.get("treatment_plan", ["No treatment plan"])),
        "diagnostic_tests": ", ".join(clinical_data.get("diagnostic_test", ["No tests required"])),
        "follow_up_date": clinical_data.get("follow_up", "No follow-up scheduled"),
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M")
    }

async def handle_new_appointment(details: dict) -> str:
    return (
        "New appointment confirmed:\n"
        f"Date: {details.get('start', 'N/A')}\n"
    )

async def handle_reschedule(current_details: dict, original_details: dict) -> str:
    return (
        "Appointment rescheduled:\n"
        f"Original: {original_details.get('start', 'N/A')}\n"
        f"New Time: {current_details.get('start', 'N/A')}\n"
        f"Changes: {find_changes(original_details, current_details)}"
    )

async def handle_deletion(previous_details: dict) -> str:
    return (
        "Appointment cancelled:\n"
        f"Original Date: {previous_details.get('start', 'N/A')}\n"
    )

def find_changes(old: dict, new: dict) -> str:
    changes = []
    for key in ['start']:
        old_val = old.get(key, 'N/A')
        new_val = new.get(key, 'N/A')
        if old_val != new_val:
            changes.append(f"{key}: {old_val} → {new_val}")
    return "\n".join(changes) if changes else "No significant changes"

monitoring_agent = AssistantAgent(
    name="MonitoringAgent",
    model_client=model_client,
    system_message="You are Monitoring Agent. Watch for appointment, patient-case, and insurance status changes; format succinct update summaries; and trigger notifications.",
    tools=[monitor_appointments, monitor_patient_case, monitor_insurance_verification],
    reflect_on_tool_use=True
)

notification.py:
PATIENT_TEMPLATES = {
    "created": """
    <h3>Appointment Confirmed</h3>
    <p>Dear {patient_name},</p>
    <p>Your appointment has been scheduled for:</p>
    <p><strong>{date}</strong> at <strong>{time}</strong></p>
    {signature}
    """,
    
    "rescheduled": """
    <h3>Appointment Updated</h3>
    <p>Dear {patient_name},</p>
    <p>Your appointment has been rescheduled to:</p>
    <p><strong>{date}</strong> at <strong>{time}</strong></p>
    {signature}
    """,
    
    "deleted": """
    <h3>Appointment Cancelled</h3>
    <p>Dear {patient_name},</p>
    <p>Your appointment has been cancelled.</p>
    {signature}
    """
}

DOCTOR_TEMPLATES = {
    "created": """
    <h3>New Appointment Scheduled</h3>
    <p>New patient appointment:</p>
    <ul>
        <li>Patient: {patient_name}</li>
        <li>Date: {date}</li>
        <li>Time: {time}</li>
    </ul>
    {signature}
    """,
    
    "rescheduled": """
    <h3>Appointment Rescheduled</h3>
    <p>Appointment update for {patient_name}:</p>
    <p>New time: {date} at {time}</p>
    {signature}
    """,
    
    "deleted": """
    <h3>Appointment Cancelled</h3>
    <p>Appointment with {patient_name} has been cancelled.</p>
    {signature}
    """
}

PATIENT_CASE_REVIEW_TEMPLATE = """
    <h3>Medical Review Summary for {patient_name}</h3>
    <p><strong>Date:</strong> {timestamp}</p>
    
    <div style="margin: 20px 0;">
        <h4>Diagnosis:</h4>
        <p>{diagnosis}</p>
        
        <h4>Recommended Treatment Plan:</h4>
        <ul>
            {treatment_plan}
        </ul>
        
        <h4>Required Tests:</h4>
        <p>{diagnostic_tests}</p>
        
        <h4>Follow-Up Date:</h4>
        <p>{follow_up_date}</p>
    </div>
    
    <p style="color: #666;">
        {signature}
    </p>
"""

INSURANCE_FOUND_TEMPLATE = """
    <h3>Insurance Verification Complete</h3>
    <p><strong>Patient:</strong> {patient_name}</p>
    <p><strong>Service:</strong> {service}</p>
    <p><strong>Date:</strong> {timestamp}</p>
    
    <div style="margin: 20px 0;">
        {status_message}
        {coverage_details}
    </div>
    
    <p style="color: #666;">
        {signature}
    </p>
"""

COVERAGE_STATUS_BLOCK = """
        {status_icon} {status_message}
        <ul>
            {coverage_details}
        </ul>
"""

COVERAGE_DETAILS = """
            <li>Provider: {provider}</li>
            <li>Copay Amount: {copay}</li>
            <li>Authorization Required: {authorization_required}</li>
"""

NOT_COVERED_MESSAGE = """
        <h4 style="color: #cc0000;">✗ This service is not covered</h4>
        <p>Service "{service}" is not included in your insurance plan.</p>
"""

INSURANCE_NOT_FOUND_TEMPLATE = """
<html>
<body>
    <h3>Insurance Verification Issue</h3>
    <p><strong>Patient:</strong> {patient_name}</p>
    <p><strong>Date:</strong> {timestamp}</p>
    
    <div style="margin: 20px 0; color: #cc0000;">
        <h4>Verification Failed:</h4>
        <p>{error_message}</p>
    </div>
    
    <p style="color: #666;">
        Please contact our support team for assistance.<br>
        {signature}
    </p>
</body>
</html>
"""

signature = (
    "<strong>HealthCare Agent</strong><br>"
    "OZ Digital Consulting<br>"
)

token_response = get_access_token()
access_token = token_response["data"]

user_email = 'annew@CRM422952.onmicrosoft.com'
doctor_email = 'aliciat@CRM422952.onmicrosoft.com'

async def send_email(email_subject: str, token: str, blob_name: str, recipient_emails: List[str], **kwargs: Any):
    try:
        url = f'https://graph.microsoft.com/v1.0/users/{doctor_email}/sendMail'
        headers = {
            "Authorization": f"Bearer {token}",
        }
        email_template = blob_name

        email_content = email_template.format(
            **kwargs,
        )

        email_msg = {'Message':
                        {'Subject': email_subject,
                                'Body': {
                                    'ContentType': 'HTML',
                                    'Content': email_content
                                },
                            'ToRecipients':[{"EmailAddress": {"Address": email}} for email in recipient_emails],
                        },
                            'SaveToSentItems': 'true'
                    }
        
        email = requests.post(url, headers=headers, json=email_msg)

        if email.status_code == 202:
            return {"status": "success", 
                    "message": "Email sent successfully."}
        else:
            return {"status": "failure", 
                    "message": f"Failed to send email. {email.status_code}"}

    except Exception as e:
        return {"status": "exception", 
                "message": f"An exception occured while sending notification.",
                "exception_message": str(e)}

def format_patient_message(details: dict, messages: list) -> str:
    
    date_str, time_str = format_time(details.get('start', ''))
    
    return {
        'patient_name': details.get('patient_name', 'Patient'),
        'date': date_str,
        'time': time_str,
        'signature': signature
    }

def format_doctor_message(details: dict, messages: list) -> str:
    
    date_str, time_str = format_time(details.get('start', ''))
    
    return {
        'patient_name': details.get('patient_name', 'Patient'),
        'date': date_str,
        'time': time_str,
        'signature': signature
    }

def format_time(datetime_str: str) -> tuple:
    """Convert custom datetime string to formatted PKT time"""
    try:

        dt_str = datetime_str.replace(' PKT+', '+').replace(' ', 'T')
        dt = parser.parse(dt_str)

        pkt = tz.gettz('Asia/Karachi')

        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=pkt)
        else:
            dt = dt.astimezone(pkt)

        if platform.system() == 'Windows':
            time_fmt = "%#I:%M %p"
        else:
            time_fmt = "%-I:%M %p"
        
        date_str = dt.strftime("%B %d, %Y")
        time_str = dt.strftime(time_fmt) + " PKT"
        
        return date_str, time_str
        
    except Exception as e:
        print(f"Time parsing error: {str(e)}")
        return ("Unknown date", "Unknown time")

def format_insurance_parameters(data: dict) -> dict:
    """Ensure all template parameters are present"""
    base_params = {
        "patient_name": data.get("patient_name", "Patient"),
        "service": data.get("service", "Unknown Service"),
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M"),
        "signature": signature,
        "status_message": "",
        "coverage_details": ""
    }
    
    if data.get("insurance_found"):
        coverage_status = "covered" if data.get("service_covered") else "not covered"
        base_params["status_message"] = f'Service {coverage_status}'
        
        if data.get("service_covered"):
            base_params["coverage_details"] = """
                <ul>
                    <li>Provider: {provider}</li>
                    <li>Copay Amount: {copay}</li>
                    <li>Authorization Required: {auth_required}</li>
                </ul>
            """.format(
                provider=data.get("provider", "Unknown"),
                copay=f"${data.get('coverage_details', {}).get('copay', 0)}",
                auth_required="Yes" if data.get('coverage_details', {}).get('requires_authorization') else "No"
            )
        else:
            base_params["coverage_details"] = f'<p>Service "{data.get("service")}" is not covered under this plan.</p>'
    
    return base_params
from tool_decorator import label_tool

@label_tool("Notifying the doctor and patient about appointment.")
async def notify_appointment(current_details: dict, messages: list):
    # print(current_details)
    template_type = "created" if "confirmed" in messages[0] else "rescheduled" if "rescheduled" in messages[0] else "deleted" if "cancelled" in messages[0] else 'nothing'
    
    patient_template = PATIENT_TEMPLATES[template_type]
    doctor_template = DOCTOR_TEMPLATES[template_type]

    patient_params = format_patient_message(current_details, messages)
    doctor_params = format_doctor_message(current_details, messages)
    
    patient_noti_status = await send_email(
        email_subject=f"Your Appointment: {current_details['subject']}",
        token=access_token,
        blob_name=patient_template,
        recipient_emails=[user_email],
        **patient_params
    )

    doctor_noti_status = await send_email(
        email_subject=f"Appointment Update: {current_details['patient_name']}",
        token=access_token,
        blob_name=doctor_template,
        recipient_emails=[doctor_email],
        **doctor_params
    )

    print(f"Patient Status: {patient_noti_status}")
    print(f"Doctor Status: {doctor_noti_status}") 

async def notify_clinical_review(patient_name: str, message_params: dict,):
    print('notify clinical review function')
    print(patient_name)
    params = {
            "signature": signature,
            "patient_name": patient_name
        }
    params.update(message_params)
    clinical_review_noti_status = await send_email(
        email_subject=f"Medical Review Summary",
        token=access_token,
        blob_name=PATIENT_CASE_REVIEW_TEMPLATE,
        recipient_emails=[user_email],
        **params
    )

    return (f"Clinical Review Status: {clinical_review_noti_status}") 

async def notify_insurance_status(patient_name: str, insurance_data: dict, message_type: str):
    """Works with existing send_email function"""
    try:
        params = format_insurance_parameters(insurance_data)
        
        return await send_email(
            email_subject=f"Insurance Update - {patient_name}",
            token=access_token,
            blob_name=INSURANCE_FOUND_TEMPLATE,
            recipient_emails=[user_email],
            **params
        )
        
    except Exception as e:
        print(f"Insurance notification failed: {str(e)}")
        return {"status": "error", "message": str(e)}
    
notification_agent = AssistantAgent(
    name="NotificationAgent",
    model_client=model_client,
    system_message="You are Notification Agent. Prepare and send templated HTML emails via Graph API for appointments, clinical reviews, and insurance updates. Log and report send status.",
    tools=[notify_appointment, notify_clinical_review, notify_insurance_status, send_email],
    reflect_on_tool_use=True
)

planner.py:
agents = [appointment_agent, doctor_agent, insurance_verification_agent, monitoring_agent, notification_agent, patient_intake_agent, clinical_recommendation_agent]

class CallCollector(ast.NodeVisitor):
    def __init__(self):
        self.calls = []

    def visit_Call(self, node):
        func_node = node.func
        func_name = (
            func_node.id if isinstance(func_node, ast.Name)
            else func_node.attr if isinstance(func_node, ast.Attribute)
            else None
        )
        if func_name:
            self.calls.append(func_name)
        self.generic_visit(node)

class StepSchema(BaseModel):
    agent: str
    function: str
    nested_functions: List[str]

class PlanSchema(BaseModel):
    summary: str
    steps: List[StepSchema]

async def create_plan(user_query: str):
    agent_info_lines = ["Agents and tools:"]
    for agent in agents:
        tool_names = ", ".join([func._name for func in agent._tools])
        agent_info_lines.append(f"{agent.name} (tools: {tool_names})")
    agents_and_tools = "\n".join(agent_info_lines)

    prompt = await generate_prompt(user_query, agents_and_tools) 

    resp = await model_client.create([SystemMessage(content=prompt)])
    plan_text = resp.content.strip()

    match = re.search(r"<PLAN_START>(.*?)<PLAN_END>", plan_text, re.DOTALL)
    if match:
        json_str = match.group(1).strip()

        plan = json.loads(json_str)
        functions = [step["function"] for step in plan["steps"]]

        # print("Functions:", functions)
        tool_name_map = get_tool_name_map()
        plan = [(tool_name_map[fn][0], fn) for fn in functions if fn in tool_name_map]
        print(plan) 
        return plan
    else:
        print("Plan not found.")

async def generate_prompt(objective: str, agents_and_tools: str):
    prompt = f"""
    You are the Planner, an AI orchestrator that manages a group of AI agents to accomplish healthcare related tasks. Remember: You are bounded to stay inside the boundaries of healthcare related queries. Anything other than that is asked, respond that you are not capable of that.

    For the given objective, come up with a simple step-by-step plan.
    This plan should involve individual tasks that, if executed correctly, will yield the correct answer. Do not add any superfluous steps.
    The result of the final step should be the final answer. Make sure that each step has all the information needed - do not skip steps.

    These actions are passed to the specific agent. Make sure the action contains all the information required for the agent to execute the task.

    Your objective is:
    {objective}

    The agents and their tools that you have access to are:
    {agents_and_tools}

    The first step of your plan should be to ask the user for any additional information required to progress the rest of steps planned.

    If it is a general healthcare industry related question like "Why would my doctor order a chest X-ray?" then just answer right away, you don't need to get into details of functions then.
    Other than that Only use the functions provided as part of your plan. If the task is not possible with the agents and tools provided and the task is of type that LLM can't answer it then create a step with the agent of type Exception and mark the overall status as completed. But if you can answer it then directly give the answer no need for exception in that case.
    Remember only the doctor agent can call the Clinical recommendation agent so if the function: generate_clinical_recommendations is called then the doctor agent should be called with function: review_patient_case and not the clinical recommendation agent because its part of the review_patient_case function.
    
    If the tools of Patient Intake Agent are called then the tool of Doctor agent should also be called: review_patient_case. 
    If the patient comes up with their details or say they are here then there is no need for appointment scheduling and cosider that they have already booked an appointment.

    Do not add superfluous steps - only take the most direct path to the solution, with the minimum number of steps. Only do the minimum necessary to complete the goal.

    If there is a single function call that can directly solve the task, only generate a plan with a single step.

    When generating the action in the plan, frame the action as an instruction you are passing to the agent to execute. It should be a short, single sentence. Include the function to use. For example, "Patient (Jessica Smith)'s case needs to be reviewed. Agent: DoctorAgent Function: review_patient_case"

    Ensure the summary of the plan and the overall steps is less than 50 words. 

    You must prioritise using the provided functions to accomplish each step. First evaluate each and every function the agents have access too. Only if you cannot find a function needed to complete the task, and you have reviewed each and every function, and determined why each are not suitable, there are two options you can take when generating the plan.
    
    If a general Large Language Model CAN handle the step/required action, add a step to the plan with the action you believe would be needed, and add "EXCEPTION: No suitable function found. A generic LLM model is being used for this step." to the end of the action. Assign these steps to the GenericAgent. For example, if the task is to convert the following SQL into python code (SELECT * FROM employees;), and there is no function to convert SQL to python, write a step with the action "convert the following SQL into python code (SELECT * FROM employees;) EXCEPTION: No suitable function found. A generic LLM model is being used for this step." and assign it to the GenericAgent.
    First evaluate whether the step could be handled by a typical large language model, without any specialised functions but this needs to be related to healthcare.
    
    Limit the plan to 6 steps or less.
    Return the plan in this exact format:

    <PLAN_START>
    {{
    "summary": "short summary here",
    "steps": [
        {{
        "agent": "AgentName",
        "function": "FunctionName"
        }},
        {{
        "agent": "AgentName",
        "function": "FunctionName"
        }},
        rest of the functions....
        ...
    ]
    }}
    <PLAN_END>
    """

    return prompt

def check_nested_funcs(plan_text: List[str]):
    functions = plan_text
    # Collect all tool function names across agents
    tool_name_map = {}
    for agent in agents:
        for tool in agent._tools:
            func = getattr(tool, "func", getattr(tool, "_func", None))
            if func:
                tool_name_map[func.__name__] = (agent.name, tool._name)
                # print(func)

    lines = []
    for agent in agents:
        for tool in agent._tools:
            if tool._name in functions:
                lines.append(f"- {agent.name}: {tool._name}")
                try:
                    func = getattr(tool, "func", getattr(tool, "_func", None))
                    if func is None:
                        continue
                    src = inspect.getsource(func)
                    tree = ast.parse(src)
                    calls = []
                    for node in ast.walk(tree):
                        if isinstance(node, ast.Call):
                            func_node = node.func
                            func_name = (
                                func_node.id if isinstance(func_node, ast.Name)
                                else func_node.attr if isinstance(func_node, ast.Attribute)
                                else None
                            )
                            if func_name and func_name in tool_name_map:
                                calls.append(func_name)
                    if calls:
                        unique_calls = sorted(set(calls))
                        lines.append(f"    * Calls agent tools: {', '.join(unique_calls)}")
                        plan_text.extend(unique_calls)
                except Exception as e:
                    print(f"Error parsing {tool._name}: {e}")

    return ("\n".join(lines))

def get_tool_name_map():
    tool_name_map = {}
    for agent in agents:
        for tool in agent._tools:
            func = getattr(tool, "func", getattr(tool, "_func", None))
            if func:
                tool_name_map[func.__name__] = (agent.name, tool._name, func)
    return (tool_name_map)

def resolve_function_sequence(start_funcs: List[str], tool_name_map: dict) -> List[tuple]:
    seen = set()
    ordered_sequence = []

    def dfs(func_name):
        if func_name not in tool_name_map or func_name in seen:
            return
        seen.add(func_name)

        agent_name, tool_name, func = tool_name_map[func_name]

        try:
            src = inspect.getsource(func)
            tree = ast.parse(src)
            collector = CallCollector()
            collector.visit(tree)

            ordered_sequence.append((agent_name, tool_name))
            for nested in collector.calls:
                dfs(nested)

        except Exception as e:
            print(f"Error parsing {func_name}: {e}")

    for func_name in start_funcs:
        dfs(func_name)

    return ordered_sequence

# pprint(asyncio.run(create_plan('i want to book an appointment and get my insurance checked.')))

planner_agent = AssistantAgent(
    name="PlannerAgent",
    model_client=model_client,
    system_message="You are a planner.",
    tools=[create_plan],
)


the query is routed towards the planner agent and it returns a plan which should be executed in order to complete the task in query.
the plan is in this format: 
[(agent1, function), (agent2, function)]